    数组是由同一种数据类型的元素系列组成的。数组元素按顺序存储与内存中，通过使用数组索引（或偏移量）来访问。在 C 中，首元素的索引值为0，因此包含 n 个元素的数组的末元素索引为 n-1 。程序员要能够正确地使用数组索引，因为编译器和程序运行时都不检查索引是否合法。
    要声明一个简单的一维数组，可以采用下面的形式：
    type name[size];
    此处，type 是数组内每个元素的数据类型，name 是数组名，size 是元素个数。传统上，C 要求 size 是一个常量整数表达式。
    C 把数组名解释为该数组首元素的地址，数组名和指向首元素的指针是等价。通常，数组和指针是紧密联系的。如果 ar 是数组，那么表达式 ar[i] 和 *(ar+i) 是等价的。
    C 不支持把整个数组作为函数参数进行传递，但是可以传递数组的地址。然后函数可以利用该地址来处理原始数组。如果函数功能不需要修改原始数组，那么在声明相应的形式参数时，需要加上关键字 const。在被调用函数中，你可以是使用数组符号或指针符号。无论哪种形式，实际上使用的都是指针变量。
    对指针加上一个整数或进行增量运算时，指针值的改变都是以所指向对象的字节大小为单位的。也就是说，如果 pd 指向数组内的一个 8 自己长的 double 数值，则对 pd 加 1 就相当于对它的值加上数值8。这样样，该指针会这项数组的下一个元素。
    二维数组表示数组的数组。例如：
    double sales[5][12];
    这个声明创建了包含 5 个元素的数组 sales，每个元素包含 12 个 double 数。这些一维数组的第 1 个可以写作 sales[0]，第 2 个可以写作 sales[1]，等等。每个都包含 12 个 double 数的数组。使用第二个索引可以访问这些数组中的每一个元素。例如，sales[2][5] 是 sales[2] 的第 6 个元素，sales[2] 是 sales 的第 3 个元素。
    传统的 C 向函数传递多维数组的方法是把数组名（也就是地址）传递给相应类型的指针变量。指针的声明需要指向各维的大小（除了最左面的不许要明确之处大小）；第一个参数的维数大小通常作为第二个参数来传递。例如，要处理前面提到的数组 sales，函数原型和函数调用应该如下：
    void display(double ar[][12], int rows);
    ...
    display(sales, 5);
    另一种方法，两个维大小都可以作为参数被传递给函数。因此，函数原型和函数调用就可以如下这样写：
    void display(int rows, int cols, double ar[rows][cols]);
    ...
    display(5, 12, sales);
    本例使用了 int 数组和 double 数组，对于其他类型的数组，结论也都适合。然而，字符串有很多特殊的规则。这是有它的终止 '\0' 字符决定的。有了这个终止符，无论向函数传递字符串大小，函数就能够检测字符串的结束。

key:

    当需要存储同种类型的许多元素时，数组是最佳选择。C 把数组归类与派生类型是因为它是建立在其他类型之上的。也就是说，你不仅仅声明了一个数组，而是声明了一个 int 数组、float 数组或者其他类型的数组。所谓的其他类型本身就是一种数组类型，在这种情况下，可以得到数组的数组，或成为二维数组。
    编写处理数组的函数常常是有用的，因为使特定的函数执行特定的功能有助于程序的模块化。使用数组名作为实际参数时，主要的一点是要知道并不是把整个数组传递给数组，而是传递它的地址：因此相应的形式参数是一个指针。处理数组时，函数必须知道数组的地址和元素的个数。数组地址直接传递给函数，而数组元素的个数信息需要内建于函数内部或被作为独立的参数传递给函数。后者更为通用，因为这种方法可以处理不同大小的数组。
    数组和指针之间是紧密联系的，指针符号和数组符号的运算有时可以互换使用。正式由于这种紧密的联系，才允许处理数组的函数使用指针（而不是数组）作为形式参数，同时在函数中使用数组符号处理数组。
    必须用一个常量表达式为传统的 C 数组指定数组的大小，因此在编译时数组大小已经确定。
